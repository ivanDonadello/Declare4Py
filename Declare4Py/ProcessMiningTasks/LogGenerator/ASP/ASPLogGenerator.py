from __future__ import annotations

import collections
import logging
import math
import re
import typing
import warnings
from datetime import datetime, timedelta
import random
from random import randrange
import os

import clingo
import pm4py
from clingo import Symbol
import pandas as pd

# NEW
from Declare4Py.ProcessMiningTasks.AbstractLogGenerator import AbstractLogGenerator
from Declare4Py.ProcessMiningTasks.LogGenerator.ASP.ASPUtils.ASPTemplate import ASPTemplate
from Declare4Py.ProcessMiningTasks.LogGenerator.ASP.ASPUtils.ASPEncoding import ASPEncoder
from Declare4Py.ProcessMiningTasks.LogGenerator.ASP.ASPUtils.ASPResultModel import ASPResultTraceModel
from Declare4Py.ProcessMiningTasks.LogGenerator.ASP.ASPTranslator.ASPModel import ASPModel

# OLD

from Declare4Py.ProcessModels.DeclareModel import DeclareModel, DeclareParsedDataModel, \
    DeclareModelConstraintTemplate, DeclareModelAttributeType, DeclareModelAttr


class LogTracesType(typing.TypedDict):
    positive: typing.Union[typing.List, typing.Dict]
    negative: typing.Union[typing.List, typing.Dict]


class AspGenerator(AbstractLogGenerator):
    """
    A generator that generates ASP logs. It analyzes Declare models, converts them to ASP and feeds them into Clingo.
    The ASP generator then analyzes the traces generated by clingo and creates a set of traces that respect the Declare model constraints and definitions.
    The set of traces can then be exported in csv or xes files
    """

    def __init__(self,
                 decl_model: DeclareModel,
                 num_traces: int,
                 min_event: int,
                 max_event: int,
                 encode_decl_model: bool = True,
                 include_boundaries: bool = True,
                 verbose: bool = False
                 ):
        """
        ASP generates the log from declare model which translate declare model
        into ASP, and then it passes to the clingo, which generates the traces

        Parameters
        ----------
        decl_model: DeclModel
            Declare model object
        num_traces: int
            an integer representing the number of traces to generate
        min_event: int
            an integer representing the minimum number of events that a trace can have
        max_event: int
            an integer representing the maximum number of events that a trace can have
        encode_decl_model: boolean
            indicating whether the declare model should be encoded or not.

        Because, clingo doesn't accept some names such as a name starting with capital letter.

        """
        """Super class LogGenerator"""
        super().__init__(num_traces, min_event, max_event, decl_model, None, verbose)

        """DEF Logger"""
        self.__ASP_Log_Gen_Logger: logging.Logger = logging.getLogger("ASP generator")

        """ Clingo Config """
        self.use_custom_clingo_config: bool = False
        self.clingo_commands: typing.Dict[str, str] = {"CONFIG": "--configuration={}", "THREADS": "-t {}", "FREQUENCY": "--rand-freq={}", "SIGN-DEF": "--sign-def={}", "MODE": "--opt-mode={}", "STRATEGY": "--opt-strategy={}", "HEURISTIC": "--heuristic={}"}
        self.default_configuration: typing.Dict[str, str] = {"CONFIG": "frumpy", "THREADS": str(os.cpu_count()), "FREQUENCY": "1.0", "SIGN-DEF": "asp", "MODE": "optN", "STRATEGY": None, "HEURISTIC": None}
        self.custom_configuration: typing.Dict[str, str] = self.default_configuration.copy()

        """DEF clingo outputs"""
        self.clingo_output: typing.List = []
        self.clingo_current_output: typing.Sequence[Symbol]
        self.clingo_output_traces_variation: typing.Dict = {}

        self.result_traces: LogTracesType = LogTracesType(negative=[], positive=[])
        self.result_traces_variation: LogTracesType = LogTracesType(negative=[], positive=[])

        """DEF TRACES"""
        self.positive_traces = self.log_length
        self.negative_traces = 0
        self.positive_traces_distribution: collections.Counter = collections.Counter()
        self.negative_traces_distribution: collections.Counter = collections.Counter()

        """DEF ASP outputs"""
        # self.asp_generated_traces: typing.List[ASPResultTraceModel] | None = None
        self.asp_generated_traces: typing.Union[LogTracesType, None] = None
        self.asp_encoding = ASPEncoder().get_asp_encoding()
        self.asp_template: str = ASPTemplate

        """DEF specs and counters"""
        self.num_repetition_per_trace: int = 0
        self.trace_counter: int = 0
        self.trace_variations_key_id: int = 0
        self.trace_counter_id: int = 0

        self._custom_counter: dict[str, typing.Union[collections.Counter, None]] = {"positive": None, "negative": None}
        self.include_boundaries: bool = include_boundaries

        """DEF Model"""
        self.lp_model: typing.Union[ASPModel, None] = None
        self.traces_generated_events: typing.Union[typing.List, None] = None
        self.encode_decl_model: bool = encode_decl_model

        """Logger opt"""
        self.__debug_message(f"Distribution for traces {self.distribution_type}")
        self.__debug_message(f"traces: {num_traces}, events can have a trace min({self.min_events}) max({self.max_events})")

        # Constraint violations
        """
        A trace is positive if it satisfies all three constraints that are defined in this model. Whereas it is
        negative if at least one of them is not satisfied. In the generated log you sent me, in all traces the 
        constraint " Response[Driving_Test, Resit] |A.Grade<=2 | " is not satisfied, i.e. it is violated!
        """
        self.violate_all_constraints: bool = False  # if false: clingo will decide itself the constraints to violate
        self.violable_constraints: [str] = []  # constraint list which should be violated

        # constraint template conditions
        self.activation_conditions: dict = {}

    def run(self, generated_asp_file_path: typing.Union[str, None] = None):
        """
        Starts the process of generating the ASP log, first calculates the distribution of the traces, then generates the positive traces and at the end it generates the negative traces.

        Parameters
            generated_asp_file_path:
                The path of the ASP log to be generated

        """

        # --- Set up the traces distribution to generate ---
        self.trace_counter = 0

        if self._custom_counter["positive"] is not None and self._custom_counter["negative"] is not None:
            self.__debug_message("Using custom trace distribution")
            # Copy the traces
            self.positive_traces_distribution = self._custom_counter["positive"]
            self.negative_traces_distribution = self._custom_counter["negative"]
            # Get the respective length
            self.positive_traces = sum(self.positive_traces_distribution.values())
            self.negative_traces = sum(self.negative_traces_distribution.values())
        else:
            # Calculate the distribution for the current
            self.positive_traces_distribution = self.compute_distribution(self.positive_traces)
            if self.negative_traces > 0:
                self.negative_traces_distribution = self.compute_distribution(self.negative_traces)

        # Setting the overall length of the traces
        self.log_length = self.positive_traces + self.negative_traces

        self.__debug_message(f"Prepared distribution of {self.positive_traces} positive traces with distribution: {self.positive_traces_distribution}")
        self.__debug_message(f"Prepared distribution of {self.negative_traces} negative traces with distribution: {self.negative_traces_distribution}")

        # --- Generating Positive traces ---

        self.result_traces: LogTracesType = LogTracesType(negative=[], positive=[])
        self.result_traces_variation: LogTracesType = LogTracesType(negative=[], positive=[])

        self.__debug_message("Generating positive Traces")

        asp = self.generate_asp_from_decl_model(self.encode_decl_model, generated_asp_file_path)

        self.__run_clingo_per_trace_set(asp, self.positive_traces_distribution, "positive")

        self.result_traces['positive'] = self.clingo_output
        self.result_traces_variation['positive'] = self.clingo_output_traces_variation

        # --- Generating Negative traces (if possible) ---

        if self.negative_traces > 0:

            self.__debug_message("Generating negative traces")

            violation = {'constraint_violation': True, 'violate_all_constraints': self.violate_all_constraints}
            dupl_decl_model = self.__get_decl_model_with_violate_constraint()
            path = None if generated_asp_file_path is None else generated_asp_file_path + 'neg.lp'
            asp = self.generate_asp_from_decl_model(self.encode_decl_model, path, dupl_decl_model, violation)
            self.__run_clingo_per_trace_set(asp, self.negative_traces_distribution, "negative")

            self.result_traces['negative'] = self.clingo_output
            self.result_traces_variation['negative'] = self.clingo_output_traces_variation

        self.__debug_message(f"Traces generated. Positive: {len(self.result_traces['positive'])} Neg: {len(self.result_traces['negative'])}. Parsing Trace results.")

        # --- Resolving traces ---

        self.__resolve_clingo_results(self.result_traces)
        self.__resolve_clingo_results_variation(self.result_traces_variation)
        self.__debug_message("Parsing result traces")
        self.__pm4py_log()

    def __run_clingo_per_trace_set(self, asp: str, traces_to_generate: collections.Counter, trace_type: str):
        """
        Runs clingo for each set of traces. The result will be stored into a variable and then be parsed into the converted trace

        Parameters
            asp:
                asp translation of the declare model to be used in clingo
            traces_to_generate:
                collection of traces to generate
        """

        # Resets the outputs
        self.clingo_output = []
        self.clingo_output_traces_variation = {}

        # Select the clingo configuration to use
        if self.use_custom_clingo_config:
            config = self.custom_configuration
        else:
            config = self.default_configuration

        # Creating appendable configuration to the clingo controller
        # Based on the current clingo configuration used by the generator
        configuration: typing.List = []

        for key, value in config.items():
            if value is not None:
                configuration.append(self.clingo_commands[key].format(value))

        # Definition of the method that will run clingo
        def run_clingo(asp_model: str, number_of_events: int, number_of_traces: int, trace_variation: bool = False):

            """
            Runs clingo for each set of traces.

            Parameters
                asp_model:
                    asp translation of the declare model to be used in clingo
                clingo_config:
                    current clingo configuration to use
                number_of_events:
                    number of events per trace
                number_of_traces:
                    number of traces to generate
                trace_variation:
                    Decides if the handle of clingo handles normal traces or trace variation

            Returns
                The result produced by clingo
            """

            # Generates a random seed for clingo
            seed = randrange(0, 2 ** 30 - 1)

            # Defines some important parameters for clingo
            arguments: typing.List = [
                "-c",
                f"t={int(number_of_events)}",
                f"{int(number_of_traces)}",
                f"--seed={seed}",
                "--project",
                f"--restart-on-model",
            ]

            # Appends the options of our configurations
            arguments += configuration

            # Sets up clingo
            ctl = clingo.Control(arguments)
            ctl.add(asp_model)
            ctl.add(self.asp_encoding)
            ctl.add(self.asp_template)
            ctl.ground([("base", [])], context=self)

            # Based on the trace variation the handle on clingo will be different
            variation: str = "Variation " if trace_variation else ""

            self.__debug_message(f"Total {variation}trace to generate and events: Traces:{num_traces}, Events: {num_events}, Seed:{seed}")

            if not trace_variation:
                # By default, clingo will be launched to handle the normal result
                res = ctl.solve(on_model=self.__handle_clingo_result)
            else:
                res = ctl.solve(on_model=self.__handle_clingo_variation_result)

            self.__debug_message(f"Clingo {variation}Result :{str(res)}")
            return res

        # Generate traces
        for num_events, num_traces in traces_to_generate.items():

            result = run_clingo(asp, num_events, num_traces)

            if result.unsatisfiable:
                warnings.warn(f'WARNING: Cannot generate {num_traces} {trace_type} trace/s exactly with {num_events} events with this Declare model. Check the definition of your constraints')

            # TRACE VARIATION IS NOT TESTED
            # Copied from last version of the code before refactoring
            elif self.num_repetition_per_trace > 0:

                self.trace_counter += 1
                self.clingo_output_traces_variation[len(self.clingo_output_traces_variation)] = []  # to generate the name of variation trace
                num_events = self.num_repetition_per_trace

                if num_events > 0 and self.clingo_current_output is not None:

                    c = ASPResultTraceModel(f"variation__trace_{self.trace_counter}", self.clingo_current_output)
                    asp_variation = asp + "\n"

                    for ev in c.events:
                        asp_variation = asp_variation + f"trace({ev.name}, {ev.pos}).\n"

                    result = run_clingo(asp_variation, num_events, num_traces, True)
                    if result.unsatisfiable:
                        warnings.warn(f'WARNING: Failed to generate trace variation/case.')

    def __handle_clingo_result(self, output: clingo.solving.Model):
        """A callback method which is given to the clingo """
        symbols = output.symbols(shown=True)
        self.clingo_current_output = symbols
        self.__debug_message(f" Traces generated :{symbols}")
        self.clingo_output.append(symbols)

    def __resolve_clingo_results(self, results: LogTracesType):
        """Resolve clingo produced result in customized structured
        Parameters
        ----------
        results: LogTracesType
            An object containing information about the generated traces/ solution model but to be parsed
        Returns
        -------

        """
        self.asp_generated_traces = LogTracesType(positive=[], negative=[])
        i = 0
        for result in results:  # result value can be 'negative' or 'positive'
            asp_model = []
            for clingo_trace in results[result]:
                trace_model = ASPResultTraceModel(f"case_{i}", clingo_trace)
                asp_model.append(trace_model)
                i = i + 1
            self.asp_generated_traces[result] = asp_model

    def generate_asp_from_decl_model(self,
                                     encode: bool = True,
                                     save_file: str = None,
                                     decl_model: DeclareModel = None,
                                     violation: dict = None
                                     ) -> str:
        """
        Generates an ASP translation of the Declare model.
        Parameters
        ----------
        encode: bool
            whether to use the encoded values to generate ASP
        save_file: str
            specify filepath with name, in which the generated ASP will be saved
        decl_model:
            DeclareModel which will be converted or translated into the ASP
        violation: dict
            A dictionary containing information about the constraint templates which should be violated or in order
            to generate the negative traces.

        Returns
        -------
        str
            ASP program
        """
        """
             It takes an optional encode parameter, which is a boolean
             indicating whether to encode the model or not. The default value is True.
        """
        if decl_model is None:
            decl_model = self.process_model

        self.__debug_message("Translate declare model to ASP")

        self.lp_model = ASPModel(encode).from_decl_model(decl_model, violation)

        self.__handle_activations_condition_asp_generation()
        lp = self.lp_model.to_str()

        if save_file:
            with open(save_file, 'w+') as f:
                f.write(lp)
        self.__debug_message(f"Declare model translated to ASP. Total Facts {len(self.lp_model.fact_names)}")

        if self.negative_traces > 0:
            self.asp_encoding = ASPEncoder.get_asp_encoding(self.lp_model.fact_names, False)
        else:
            self.asp_encoding = ASPEncoder.get_asp_encoding(self.lp_model.fact_names)
        self.__debug_message("ASP encoding generated")
        return lp

    def __handle_activations_condition_asp_generation(self) -> None:
        """ Handles the logic for the activations condition """
        if self.activation_conditions is None:
            return
        decl_model: DeclareParsedDataModel = self.process_model.parsed_model
        # decl_model.templates[0].template_line
        for template_def, cond_num_list in self.activation_conditions.items():
            template_def = template_def.strip()
            decl_template_parsed: [DeclareModelConstraintTemplate] = [val for key, val in decl_model.templates.items() if val.line == template_def]
            decl_template_parsed: DeclareModelConstraintTemplate = decl_template_parsed[0]
            asp_template_idx = decl_template_parsed.template_index
            if decl_template_parsed is None:
                warnings.warn("Unexpected found. Same constraint templates are defined multiple times.")
            if len(cond_num_list) == 2:
                decoder = {v: k for k, v in
                           decl_template_parsed.events_activities[0].event_name.encoder.encoded_values.items()}

                A = decoder[decl_template_parsed.events_activities[0].event_name.value]
                B = decoder[decl_template_parsed.events_activities[1].event_name.value]

                if cond_num_list[0] <= 0:
                    # left side tends to -inf or 0 starting from cond_num_list[1]. cond_num_list = [0, 2]
                    # means it can have only at most 2 activations
                    self.lp_model.add_asp_line(
                        f":- #count{{T:trace({A},T), activation_condition({asp_template_idx},T)}} < {cond_num_list[1]}.")
                    if decl_template_parsed.template.both_activation_condition:  # some templates's both conditions are activation conditions
                        self.lp_model.add_asp_line(
                            f":- #count{{T:trace({B},T), correlation_condition({asp_template_idx},T)}} < {cond_num_list[1]}.")
                elif cond_num_list[1] == math.inf:
                    # right side tends to inf from cond_num_list[0] to +inf. cond_num_list = [2, math.inf]
                    # means it can have it should at least 2 activations and can go to infinite
                    self.lp_model.add_asp_line(
                        f":- #count{{T:trace({A},T), activation_condition({asp_template_idx},T)}} > {cond_num_list[0]}.")
                    if decl_template_parsed.template.both_activation_condition:
                        self.lp_model.add_asp_line(
                            f":- #count{{T:trace({B},T), correlation_condition({asp_template_idx},T)}} > {cond_num_list[0]}.")
                else:
                    # ie cond_num_list = [2, 4]
                    # self.lp_model.add_asp_line(
                    #     f":- #count{{T:trace(A,T), activation_condition({asp_template_idx},T)}} > {cond_num_list[0]}.")
                    # self.lp_model.add_asp_line(
                    #     f":- #count{{T:trace(A,T), activation_condition({asp_template_idx},T)}} < {cond_num_list[1]}.")
                    # if decl_template_parsed.template.both_activation_condition:
                    #     self.lp_model.add_asp_line(
                    #         f":- #count{{T:trace(A,T), correlation_condition({asp_template_idx},T)}} > {cond_num_list[0]}.")
                    #     self.lp_model.add_asp_line(
                    #         f":- #count{{T:trace(A,T), correlation_condition({asp_template_idx},T)}} < {cond_num_list[1]}.")
                    self.lp_model.add_asp_line(
                        f":- #count{{T:trace({A},T), activation_condition({asp_template_idx},T)}} < {cond_num_list[0]}.")
                    self.lp_model.add_asp_line(
                        f":- #count{{T:trace({A},T), activation_condition({asp_template_idx},T)}} > {cond_num_list[1]}."
                    )
                    if decl_template_parsed.template.both_activation_condition:
                        self.lp_model.add_asp_line(
                            f":- #count{{T:trace({B},T), correlation_condition({asp_template_idx},T)}} < {cond_num_list[0]}.")
                        self.lp_model.add_asp_line(
                            f":- #count{{T:trace({B},T), correlation_condition({asp_template_idx},T)}} > {cond_num_list[1]}.")

            else:
                raise ValueError(
                    "Interval values are wrong. It must have only 2 values, represents, left and right interval")

    def __pm4py_log(self):
        """
        Generate event logs in pm4py Format
        Returns
        -------

        """

        def custom_sort_trace_key(x) -> typing.List[int]:
            # Extract the numeric parts of the string
            parts: typing.List[str] = re.findall(r'\d+', x.name)
            # Convert the numeric parts to integers
            integers: typing.List[int] = [int(p) for p in parts]
            return integers

        self.__debug_message(f"Generating Pm4py log")
        decl_model: DeclareParsedDataModel = self.get_process_model().parsed_model
        attr_list: dict[str, DeclareModelAttr] = decl_model.attributes_list
        tot_traces_generated = 0
        flattened = {}
        for result in self.asp_generated_traces:
            tot_traces_generated = tot_traces_generated + len(self.asp_generated_traces[result])
            traces_generated = self.asp_generated_traces[result]
            # traces_generated.sort(key=lambda x: x.name)
            traces_generated = sorted(traces_generated, key=custom_sort_trace_key)
            instance = []
            for trace in traces_generated:
                # Positive, Negative...
                _instance = {"trace_name": trace.name, "posNeg": result, "events": []}
                for trace_position in dict(sorted(trace.parsed_result.items())).keys():
                    asp_event = trace.parsed_result[trace_position]
                    _event = {
                        "ev": decl_model.decode_value(asp_event['name'], self.encode_decl_model),
                        "lifecycle:transition": "complete",
                        "resources": [],
                        "time:timestamp": datetime.now() + timedelta(hours=trace_position,
                                                                     seconds=random.randint(0, 3599))
                    }
                    _instance["events"].append(_event)
                    for res in asp_event['resources']:
                        res_name, res_value = list(res.items())[0]
                        # res_name_decoded = decl_model.decode_value(res_name, self.encode_decl_model)
                        # res_value_decoded = decl_model.decode_value(res_value, self.encode_decl_model)
                        res_name_decoded, res_value_decoded = self.__decode_and_scale_value(decl_model, attr_list,
                                                                                            res_name, res_value)
                        _event["resources"].append({res_name_decoded: res_value_decoded})
                instance.append(_instance)
            flattened[result] = instance
        self.traces_generated_events = flattened
        if tot_traces_generated != self.log_length:
            num = self.num_repetition_per_trace
            if num <= 0:
                num = 1
            self.__ASP_Log_Gen_Logger.warning(f'PM4PY log generated: {tot_traces_generated}/{self.log_length * num} only.')
        self.__debug_message(f"Pm4py generated but not saved yet")

    def __decode_and_scale_value(self, decl_model, attr_list, res_name, res_value):
        res_name_decoded = decl_model.decode_value(res_name, self.encode_decl_model)
        res_value_decoded = decl_model.decode_value(res_value, self.encode_decl_model)
        res_value_decoded = str(res_value_decoded)
        is_number = re.match(r"[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?", res_value_decoded)
        if is_number:
            if res_name_decoded in attr_list:
                attr = attr_list[res_name_decoded]
                if attr.value_type != DeclareModelAttributeType.ENUMERATION:
                    num = res_value_decoded
                    if attr.value_type == DeclareModelAttributeType.FLOAT_RANGE:
                        num = int(res_value_decoded) / attr.attr_value.precision
                    elif attr.value_type == DeclareModelAttributeType.INTEGER_RANGE:
                        num = int(res_value_decoded)
                    res_value_decoded = num
        if isinstance(res_value_decoded, str):
            return res_name_decoded, res_value_decoded.strip()
        else:
            return res_name_decoded, res_value_decoded

    def toPD(self, data) -> pd.DataFrame:
        activities = []
        for trace_type in data:
            for trace in data[trace_type]:
                trace_id = trace["trace_name"]
                for id_ev, event in enumerate(trace["events"]):
                    traceEvent = {
                        "case:concept:name": f'{trace_id}',
                        "time:timestamp": datetime.now() + timedelta(hours=id_ev, seconds=random.randint(0, 3599)),
                        # .isoformat(),
                        # "date": datetime.now(),
                        "lifecycle:transition": event["lifecycle:transition"],
                        "concept:name": event["ev"],
                        "case:label": trace_type,  # "complete",
                    }
                    for res in event["resources"]:
                        for k, v in res.items():
                            traceEvent[k] = v
                    activities.append(traceEvent)
        df = pd.DataFrame(activities)
        return df

    def to_csv(self, path: str):
        """
        Save log in csv file
        Parameters
        ----------
        path: str
            filename
        Returns
        -------
        """

        if self.traces_generated_events is None or len(self.traces_generated_events) == 0:
            self.__pm4py_log()
        if len(self.traces_generated_events['positive']) == 0 and len(self.traces_generated_events['negative']) == 0:
            warnings.warn("Unable to produce the logs with given model and parameters set for it.")
            return
        pd_dataframe = self.toPD(self.traces_generated_events)
        pd_dataframe.dropna(axis='columns', how='all')
        pd_dataframe.to_csv(path)

    def to_xes(self, output_fn: str):
        """
        Save log in xes file
        Parameters
        ----------
        output_fn: str
            filename
        Returns
        -------

        """
        if self.traces_generated_events is None or len(self.traces_generated_events) == 0:
            self.__pm4py_log()
        if len(self.traces_generated_events['positive']) == 0 and len(self.traces_generated_events['negative']) == 0:
            warnings.warn("Unable to produce the logs with given model and parameters set for it.")
            return
        pd_dataframe = self.toPD(self.traces_generated_events)
        pd_dataframe.dropna(axis='columns', how='all')
        pm4py.write_xes(pd_dataframe, output_fn)

        # ## Following code is to clean the NaN values not yet tested if it removes all event or just an attribute ##
        # xes = pm4py.read_xes(output_fn)
        # float_or_int_cols = pd_dataframe.select_dtypes(include=['float64', 'int64']).columns.tolist()
        # cols_with_nan = pd_dataframe[float_or_int_cols].columns[pd_dataframe[float_or_int_cols].isna().any()].tolist()
        # rows_to_remove = xes[cols_with_nan].isna().any(axis=1)
        # cleaned_xes = xes[~rows_to_remove]
        # pm4py.write_xes(cleaned_xes, output_fn)

    def use_custom_clingo_configuration(self,
                                        config: typing.Union[str, None] = None,
                                        threads: typing.Union[int, None] = None,
                                        frequency: typing.Union[float, int, None] = None,
                                        sign_def: typing.Union[str, None] = None,
                                        mode: typing.Union[str, None] = None,
                                        strategy: typing.Union[str, None] = None,
                                        heuristic: typing.Union[str, None] = None
                                        ):
        """
        Enables the use of custom clingo configuration.
        Changes the parameters of the custom configuration if the parameter is not None

        Parameters
            config:
                Clingo configuration
            threads:
                Amount of Threads to be used
            frequency:
                Random frequency
            sign_def:
                Sign of the configuration
            mode:
                Optimization of the algorithm
            strategy:
                Optimization of the strategy
            heuristic:
                Used decision heuristic
        """


        self.use_custom_clingo_config = True
        if config is not None:
            self.custom_configuration["CONFIG"] = str(config)
        if threads is not None:
            self.custom_configuration["THREADS"] = str(abs(threads))
        if frequency is not None:
            self.custom_configuration["FREQUENCY"] = str(frequency)
        if sign_def is not None:
            self.custom_configuration["SIGN-DEF"] = str(sign_def)
        if mode is not None:
            self.custom_configuration["MODE"] = str(mode)
        if strategy is not None:
            self.custom_configuration["STRATEGY"] = str(strategy)
        if heuristic is not None:
            self.custom_configuration["HEURISTIC"] = str(heuristic)

    def use_default_clingo_configuration(self):
        """
        Enables the use of default clingo configuration.
        """

        self.use_custom_clingo_config = False

    def get_current_clingo_configuration(self) -> typing.Dict[str, str]:
        """
        Returns the current clingo configuration.
        It returns the default clingo configuration if the variable use_default_clingo_configuration is False.
        It returns the custom clingo configuration if the variable use_default_clingo_configuration is True.
        """

        if self.use_custom_clingo_config:
            return self.custom_configuration
        else:
            return self.default_configuration

    def set_positive_traces(self, positive_traces: int):

        """
        Sets the number of positive traces to generate

        Parameters
            positive_traces:
                Number of positive traces to generate
        """

        if not isinstance(positive_traces, int):
            raise TypeError(f'positive_traces must be an integer and it is instead {type(positive_traces)}')
        if positive_traces <= 0:
            raise ValueError("Positive trace must be greater than 0.")

        self.positive_traces = positive_traces
        self.log_length = self.positive_traces + self.negative_traces

    def __debug_message(self, msg: any):
        """
        Used for debugging purposes, If verbose is True, the message is printed.
        """

        if self.verbose:
            self.__ASP_Log_Gen_Logger.debug(str(msg))

    # ----------- The following functionalities are not tested -----------
    # They may or may not work as intended

    def __handle_clingo_variation_result(self, output: clingo.solving.Model):
        """A callback method which is given to the clingo """
        symbols = output.symbols(shown=True)
        self.__debug_message(f" Variation traces generated :{symbols}")
        self.clingo_output_traces_variation[len(self.clingo_output_traces_variation) - 1].append(symbols)

    def __resolve_clingo_results_variation(self, variations_result: LogTracesType):
        """Resolve clingo produced variations result in particular structured """
        if self.asp_generated_traces is None:
            self.asp_generated_traces = LogTracesType(positive=[], negative=[])
        for result in variations_result:  # result value can be 'negative' or 'positive'
            asp_model = []
            for traces_key_id in variations_result[result]:
                i = 0
                for clingo_trace in variations_result[result][traces_key_id]:
                    trace_model = ASPResultTraceModel(f"case_{traces_key_id}_variation_{i}", clingo_trace)
                    asp_model.append(trace_model)
                    i = i + 1
            self.asp_generated_traces[result] = self.asp_generated_traces[result] + asp_model

    def set_constraints_to_violate(self, tot_negative_trace: int, violate_all: bool, constraints_list: list[str]):
        """
        Add constraints to violate

        Parameters
        ----------
        tot_negative_trace: int
            total negative traces to generate
        violate_all: bool
            whether to violate all the given constraint templates or let decide clingo
        constraints_list: list
            the list of the constraint templates which have to be violated.
        Returns
        -------
            declare_model_violate_constraints
        """
        assert tot_negative_trace >= 0
        self.negative_traces = tot_negative_trace
        self.log_length = self.positive_traces + self.negative_traces
        self.violate_all_constraints = violate_all
        self.add_constraints_to_violate(constraints_list)

    def set_constraints_to_violate_by_template_index(self, tot_negative_trace: int, violate_all: bool,
                                                     constraints_idx_list: list[int]):
        """
        Add constraints to violate

        Parameters
        ----------
        tot_negative_trace: int
            the number of total negative traces to generate. Cannot be greater than the Total traces len
        violate_all: bool
            whether all constraints should be violated or some of them (decided by clingo using && op)
        constraints_idx_list: list
            an integer list indicating the indexing of constraint templates

        Returns
        -------
        """
        templates: dict[int, DeclareModelConstraintTemplate] = self.get_process_model().parsed_model.templates
        constraints_list = []
        for idx in constraints_idx_list:
            constraints_list.append(templates[idx].line)
        self.set_constraints_to_violate(tot_negative_trace, violate_all, constraints_list)

    def set_number_of_repetition_per_trace(self, repetition: int):
        """
        Example: 4(number of traces) Traces with 8(repetition) repetition. Suppose we have generated 4 traces as following:
        - A B E D
        - C D A F
        - E D C A
        - B A C E
        and then for each of these trace we generate other 7 traces.
        We want clusters of traces where each cluster contains traces with the same order of events but different payload (resources or time)
        -------
        Parameters
        repetition: int
            number of repetition for each trace.
        """
        self.num_repetition_per_trace = repetition

    def __get_decl_model_with_violate_constraint(self) -> DeclareModel:
        """
        Creates a duplicate process model with change in template list, assigning a boolean value to `violate` property

        Returns
        -------
        DeclModel
        """
        parsed_tmpl: dict[int, DeclareModelConstraintTemplate] = self.get_process_model().parsed_model.templates
        for cv in self.violable_constraints:
            for tmpl_idx, tmpl in parsed_tmpl.items():
                if tmpl.line == cv:
                    tmpl.violate = True
        return self.get_process_model()

    def set_activation_conditions(self, activations_list: dict[str, list[int]]):
        """
        the activation conditions are used TODO: add more info about it.
        TODO: this method should be in the ASPLogGeneration generator rather than abstract class and also self.activation_conditions.

        Parameters
        ----------
        : param activations_list dict: accepts a dictionary with key as a string which represent a declare model
            constraint template, and value as an list with number values.
            i.e 'Response[A,B] | A.attribute is value1 | |': [3, 5].
            Here key represents a constraint template and the number list represents how many times activation key of
            that constraint template should be occurred. In this example we are saying, that it should at least 3 times
            and at most 5 times.
            the value must be a list of 2 integer which represents the bounding limits of activation. You can add math.inf
            as the 2 second element. First element should be greater or equal than 0.

        Returns
        -------

        """
        self.activation_conditions = activations_list
        return self

    def set_activation_conditions_by_template_index(self, activations_list: dict[int, list[int]]):
        """
        we want to specify rules for the activations, that is a number for the activation events.

        Parameters
        ----------
        : param activations_list dict: accepts a dictionary with key as a string which represent a declare model
            constraint template, and value as an list with number values.
            i.e 'Response[A,B] | A.attribute is value1 | |': [3, 5].
            Here key represents a constraint template and the number list represents how many times activation key of
            that constraint template should be occurred. In this example we are saying, that it should at least 3 times
            and at most 5 times.

        Returns
        -------

        """
        # indexes = activations_list.keys()  # indexes of constraint templates
        templates = self.get_process_model().parsed_model.templates
        n_dict = {}
        for m, n in activations_list.items():
            n_dict[templates[m].line] = n
        self.activation_conditions = n_dict
        return self

    def set_custom_trace_lengths(self, custom_lengths: dict[int, int],
                                 negative_custom_lengths: dict[int, int] | None = None):
        """
        Set custom traces lengths in order to generate positive and negative traces instead of
        using the distributions
        
        the key in the dict represents the number of events in a trace and value in the dict represents the number of traces with event
        i.e {68: 2} means that you want 2 traces with 68 events in each.
        
        Parameters
        ----------
        custom_lengths: dict[int, int]
            traces length for positive traces
        negative_custom_lengths: dict[int, int], Optional
            traces length for negative traces
        Returns
        -------
        """

        if custom_lengths and len(custom_lengths) > 0:
            # self.traces_length = len(custom_lengths)
            self.traces_length = sum(custom_lengths.values())
            events = custom_lengths.keys()
            self.min_events = min(events)
            self.max_events = max(events)

        if negative_custom_lengths:
            if len(negative_custom_lengths) > 0:
                events = negative_custom_lengths.keys()
                self.min_events = min(events, self.min_events)
                self.max_events = max(events, self.max_events)
            self.negative_traces = sum(negative_custom_lengths.values())
            self.traces_length = self.traces_length + self.negative_traces
        self.__ASP_Log_Gen_Logger.info(f"****----**** Trace lengths, min_events, max_events are updated ****----****")
        self.__ASP_Log_Gen_Logger.info(
            f"**--** Pos: {self.traces_length}, Neg: {self.negative_traces}, min {self.min_events}, max: {self.max_events} **--**")
        self._custom_counter = {"positive": custom_lengths, "negative": negative_custom_lengths}

    def add_constraints_to_violate(self, constrains_to_violate: typing.Union[str, list[str]] = True):
        if isinstance(constrains_to_violate, str):
            self.violable_constraints.append(constrains_to_violate)
        else:
            self.violable_constraints = constrains_to_violate
        return self


"""
if __name__ == "__main__":
    from Declare4Py.ProcessModels.DeclareModel import DeclareModel

    model_name = 'sepsis'
    model: DeclareModel = DeclareModel().parse_from_file(
        os.path.join("../../../", "tests", "test_models", f"{model_name}.decl"))
    # Number of cases that have be generated
    num_of_cases = 10

    # Minimum and maximum number of events a case can contain
    (num_min_events, num_max_events) = (6, 10)

    asp_gen: AspGenerator = AspGenerator(model, num_of_cases, num_min_events, num_max_events)
    asp_gen.run()

    asp_gen.to_csv(f'{model_name}.csv')
"""